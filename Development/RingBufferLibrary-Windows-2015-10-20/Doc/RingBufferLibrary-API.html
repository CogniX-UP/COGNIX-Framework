<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"/>
<title>RingBuffer Library 2015 API</title>
<style>
	h4 {color:green;}
	pre {
		background-color:lightgrey;
		border:1px solid grey;
		padding:10px;
		margin:30px;
	}
</style>
</head>
<body lang="EN-US">

<p>June 15, 2015</p>

<h1>2015 RingBuffer Library APIs</h1>

<h2>Contents</h2>
<ul>
	<li><a href="#typical">A Typical Acquisition Program</a></li>
<a name="toc"></a>
	<li><a href="#apis">API Calls, Alphabetical Order</a></li>
<ul>
	<li><a href="#close">CLOSE_DRIVER</a></li>
	<li><a href="#dleeprom">DOWNLOAD_FX2_EEPROM</a></li>
	<li><a href="#dlfirmware">DOWNLOAD_FX2_IIC_FIRMWARE</a></li>
	<li><a href="#bpm">GET_BYTES_PER_MSEC</a></li>
	<li><a href="#thruput">GET_CHANNEL_THROUGHPUT</a></li>
	<li><a href="#info">GET_DRIVER_INFO</a></li>
	<li><a href="#hardware">GET_HARDWARE_PARAMETER</a></li>
	<li><a href="#nchusb">GET_NUM_CHANNELS_USB</a></li>
	<li><a href="#nchxfr">GET_NUM_CHANNELS_XFR</a></li>
	<li><a href="#resyncs">GET_NUM_RESYNCS</a></li>
	<li><a href="#remotethruput">GET_REMOTE_CHANNEL_THROUGHPUT</a></li>
	<li><a href="#getstride">GET_STRIDE</a></li>
	<li><a href="#getsync">GET_SYNC</a></li>
	<li><a href="#open">OPEN_DRIVER</a></li>
	<li><a href="#multiple">READ_MULTIPLE_SWEEPS</a></li>
	<li><a href="#readp">READ_POINTER</a></li>
	<li><a href="#readpc">READ_POINTER_WITH_CYCLE</a></li>
	<li><a href="#setconnect">SET_CONNECT_NODE_PORT</a></li>
	<li><a href="#setlisten">SET_LISTEN_PORT</a></li>
	<li><a href="#setstridekb">SET_STRIDE_KB</a></li>
	<li><a href="#setstridems">SET_STRIDE_MS</a></li>
	<li><a href="#setsync">SET_SYNC</a></li>
	<li><a href="#settransfer">SET_TRANSFER_CHANNEL_REQUEST_RANGES</a></li>
	<li><a href="#usbwrite">USB_WRITE</a></li>
</ul>
</ul>

<a name="typical"></a>
<h2>A Typical Acquisition Program</h2>

<p>
An acquisition program using the RingBuffer library must use at least these API
calls, in the order shown:</p>
<ul>
	<li><a href="#open">OPEN_DRIVER</a>,
	to claim the Usb or socket interface.</li>
	<br>
	<li><a href="#usbwrite">USB_WRITE</a>,
	to send 64 zero bytes to initialize the interface.</li>
	<br>
	<ul>
	<li><a href="#multiple">READ_MULTIPLE_SWEEPS</a>,
	to declare the address and size of the ring bufffer that
	will receive the samples.</li>
	<br>
	<li><a href="#usbwrite">USB_WRITE</a>,
	to send a x'ff' byte and 63 zero bytes to start the flow of samples
	into the ring buffer.</li>
	<br>
	<ul>
	<li>Repeated <a href="#readp">READ_POINTER</a> or
	<a href="#readpc">READ_POINTER_WITH_CYCLE</a>
	to track progress through the ring buffer.</li>
	<br>
	</ul>
	<li><a href="#usbwrite">USB_WRITE</a>,
	to send 64 zero bytes to stop the flow of samples to the ring buffer.
	To start the sample flow again, repeat from the READ_MULTIPLE_SWEEPS" step above.</li>
	<br>
	</ul>
	<li><a href="#close">CLOSE_DRIVER</a>,
	to release the interface.</li>
</ul>
<br>
<br>
<br>
<br>
<a name="apis"></a>
<h2>All RingBuffer library APIs, Alphabetical Order</h2>

<a name="close"></a>
<h4>BOOL CLOSE_DRIVER(HANDLE hdevice)</h4>

</p>Closes the device being used, either Usb or TCP socket, and releases it
for re-use.</p>
Parameters:
<ul>
	<li>hdevice: Ignored but must be present, at this time.</li>
</ul>
Returns:
<ul>
	<li>TRUE if successful.</li>
	<li>FALSE if not sucessful.</li>
</ul>
<a href="#toc">Contents</a>
<br>
<br>

<a name="bpm"></a>
<h4>FLOAT GET_BYTES_PER_MSEC(void)</h4>

<p>Get the ring buffer fill rate.</p>
Parameters:
<ul>
	<li>*None*</li>
</ul>
Returns:
<ul>
	<li>Measured ring buffer fill rate, in bytes per millisecond.</li>
</ul>
<a href="#toc">Contents</a>
<br>
<br>

<a name="thruput"></a>
<h4>INT GET_CHANNEL_THROUGHPUT(void)</h4>

<p>Get the ring buffer channel fill rate.</p>
Parameters:
<ul>
	<li>*None*</li>
</ul>
Returns:
<ul>
	<li>Measured ring buffer channel fill rate, in samples per channel per second.</li>
</ul>
<p>
This is a measured fill rate.  If the buffer is being filled from a Usb,
this should be close to the actual rate at which the channel is being sampled.
If the buffer is being filled from a socket, the rate is determined using the number
of channels being transferred, which may be less than the number being sampled
remotely.  Ideally the client and server channel fill rates should closely match.
</p>
<a href="#toc">Contents</a>
<br>
<br>


<a name="info"></a>
<h4>PCHAR GET_DRIVER_INFO(PCHAR infoBuffer, SIZE_T infoSize)</h4>
<p>Get library version number and other run parameters as an ASCII string.</p>
Parameters:
<ul>
	<li>infoBuffer: Address of a character array to hold the returned string.</li>
	<li>infoSize: The dimensioned size of infoBuffer.</li>
</ul>
Returns
<ul>
	<li>Pointer to infoBuffer.</li>
</ul>

<p>
The string returned in "infoBuffer" is NULL terminated.
</p>
<a href="#toc">Contents</a>
<br>
<br>


<a name="hardware"></a>
<h4>PCHAR GET_HARDWARE_PARAMETER(INT which, PCHAR infoBuffer, SIZE_T infoSize)</h4>
<p>Get a hardware parameter as an ASCII string.</p>
Parameters:
<ul>
	<li>which: 1 for receiver chip version; 2 for receiver fpga version; 3 for AD-Box version</li>
	<li>infoBuffer: Address of a character array to hold the returned string.</li>
	<li>infoSize: The dimensioned size of infoBuffer.</li>
</ul>
Returns
<ul>
	<li>Pointer to infoBuffer.</li>
</ul>

<p>
The string returned in "infoBuffer" is NULL terminated.  If the requested parameter is not available,
a 0 length string is returned, i.e. infoBuffer[0] = 0.
</p>
<a href="#toc">Contents</a>
<br>
<br>


<a name="nchusb"></a>
<h4>INT GET_NUM_CHANNELS_USB(void)</h4>

<p>Get the number of channels being sampled.</p>
Parameters:
<ul>
	<li>*None*</li>
</ul>
Returns:
<ul>
	<li>The number of channels being sampled.  This number always includes
	the sync and status channels.</li>
</ul>
<p>This is the size of a single channel sweep in the ring buffer.  If this is
a client application taking samples from a socket and the client has requested
only a subset of samples be transferred, the sweep size still matches that being
used by the server.  Channels not transferred are set to x'ffffff00'.
</p>
<a href="#toc">Contents</a>
<br>
<br>

<a name="nchxfr"></a>
<h4>INT GET_NUM_CHANNELS_XFR(void)</h4>

<p>Get the number of channels being transferred from a remote acquisition.</p>
Parameters:
<ul>
	<li>*None*</li>
</ul>
Returns:
<ul>
	<li>The number of channels being transferred via socket.  This number always includes
	the sync and status channels.</li>
	<li>Zero, if this is not a remote acquisition.</li>
</ul>
<p>By default, all channels being acquired at the remote Usb are transferred.
A reduced number of channels can be requested using the call SET_TRANSFER_CHANNEL_REQUEST_RANGES.
</p>
<a href="#toc">Contents</a>
<br>
<br>

<a name="resyncs"></a>
<h4>INT GET_NUM_RESYNCS(void)</h4>

<p>Get the number of socket re-syncs (re-connects) that have occurred during this run.</p>
Parameters:
<ul>
	<li>*None*</li>
</ul>
Returns:
<ul>
	<li>The number of socket re-syncs that have had to be performed during this run.</li>
	<li>Zero, if this is not a remote acquisition.</li>
</ul>
<p>
Re-syncs occur when the socket transmission rate cannot keep up with the Usb acquisition
rate.  This is usually detected at the serving end and causes the server to close the channel.
The client immediately re-connects but some sets of samples are lost to the client.
By default, all channels being acquired at the remote Usb are transferred.
Reducing the number of channels being transferred should reduce the number of re-syncs.
A reduced number of channels can be requested using the call SET_TRANSFER_CHANNEL_REQUEST_RANGES.</p>
<a href="#toc">Contents</a>
<br>
<br>

<a name="remotethruput"></a>
<h4>INT GET_REMOTE_CHANNEL_THROUGHPUT(void)</h4>

<p>Get the remote ring buffer channel fill rate.</p>
Parameters:
<ul>
	<li>*None*</li>
</ul>
Returns:
<ul>
	<li>The remote ring buffer fill rate, in samples per channel per second.</li>
	<li>Zero, if this is not a remote acquisition.</li>
</ul>
<p>
This fill rate is measured by the remote application.  It should be close to the actual
rate at which the channel is being sampled.
</p>
<a href="#toc">Contents</a>
<br>
<br>

<a name="getstride"></a>
<h4>INT GET_STRIDE(void)</h4>

<p>Get the current STRIDE setting being used.</p>
Parameters:
<ul>
	<li>*None*</li>
</ul>
Returns:
<ul>
	<li>Current value of STRIDE, in milliseconds.</li>
</ul>
<p>STRIDE can be set also using parameters "stride_kb" or "stride_ms"
in the "ringbuffer.ini" file or by a call to SET_STRIDE_MS or SET_STRIDE_KB.
The default is 131072 bytes.
</p>
<a href="#toc">Contents</a>
<br>
<br>

<a name="getsync"></a>
<h4>BOOL GET_SYNC(void)</h4>

<p>Get the current SYNC setting being used.</p>
Parameters:
<ul>
	<li>*None*</li>
</ul>
Returns:
<ul>
	<li>Current value of SYNC: TRUE or FALSE.</li>
</ul>
<p>
When SYNC is TRUE, READ_POINTER and READ_POINTER_WITH_CYCLE expect position
values in the
parameters "cycleNum" and "pointer" when called and won't return until the
position changes; when SYNC is FALSE, these routines return immediately.
When the call doesn't return until there is a position
change, the caller doesn't loop burning up CPU time.
SYNC can be set on/off also by using parameter "sync" or "nosync"
in the "ringbuffer.ini" file or by calling SET_SYNC.
</p>
<a href="#toc">Contents</a>
<br>
<br>


<a name="open"></a>
<h4>HANDLE OPEN_DRIVER(void)</h4>
<p>Initializes the ring buffer support library.</p>
Parameters:
<ul>
	<li>*None*</li>
</ul>
Returns:
<ul>
	<li>Non-zero if successful.</li>
	<li>Zero if not sucessful.</li>
</ul>

<p>The ring buffer can be filled with samples from either
<ul>
	<li>a BioSemi device connected via usb or</li>
	<li>a TCP socket connected to a program that is receiving samples via usb.</li>
</ul>
The first choice is to use usb input if a BioSemi receiver is connected to
this computer via usb and the device is not being used by another program.
If usb input is not available, TCP socket input will be attempted. The node
and port of a sample server for the TCP connection can be set before this
call, otherwise a TCP connection to the current computer will be attempted.
</p>
<p>
The parameter file "ringbuffer.ini" is read during the first OPEN_DRIVER call
only.  Parameters set by API calls before that first OPEN are overridden by any
corresponding parameters in the file; parameters set after that first OPEN will
override anything set by the file.
</p>
<a href="#toc">Contents</a>
<br>
<br>


<a name="multiple"></a>
<h4>BOOL READ_MULTIPLE_SWEEPS(HANDLE hdevice,PCHAR data,INT_PTR nBytesToRead)</h4> 
<p>Creates a thread to control the acquisition process.</p>
Parameters:
<ul>
	<li>hdevice: Ignored but must be present, at this time.</li>
	<li>data: Address of the array of 32 bit words to be continously filled with samples -
the ring buffer.</li>
<li>nBytesToRead: The size of the ring buffer array, in bytes.</li>
</ul>
Returns:
<ul>
	<li>TRUE Success.</li>
	<li>FALSE Failure.</li>
</ul>

<p>Establishes the ring buffer to be used to receive samples during data
acquisition.  Starts a separate thread to control the acquisition process.
The actual flow of samples doesn't start until enabled by a call to
USB_WRITE.</p>
<p>The ring buffer can be any size as long as it is a multiple of 512
bytes (Linux and OSX) or a multiple of 4 bytes (Windows).</li>
</p>
<p>Because the ring buffer may be undergoing transmission to a remote
client via Tcp, the contents of this buffer should not be changed by the
user during acquisition.</p>
<a href="#toc">Contents</a>
<br>
<br>


<a name="readp"></a>
<h4>BOOL READ_POINTER(HANDLE hdevice,PINT_PTR pointer)</h4>
<p>Determines the position in the ring buffer (a byte index) at which new
samples are being stored.
</p>
Parameters:
<ul>
	<li>hdevice: Ignored but must be present, at this time.</li>
	<li>pointer: Address of an integer where the index value will be stored.
	The value returned will be in the range 0 to (the size of the ring buffer)-1.</li>
</ul>
Returns:
<ul>
<li>TRUE Success.</li>
<li>FALSE Failure.  Acquisition not running.</li>
</ul>

<p>
When the ring buffer is being filled from a socket rather than the Usb,
a single FALSE return indicates that a re-sync has occurred; two FALSE returns
in a row indicate that acquisition has stopped.</p>
<p>
Note: When using sync'ed READ_POINTER calls, "pointer" is an input
and output parameter.
</p>
<a href="#toc">Contents</a>
<br>
<br>


<a name="readpc"></a>
<h4>BOOL READ_POINTER_WITH_CYCLE(HANDLE hdevice,long long *cycleNum,PINT_PTR pointer)</h4>
<p>Determines the cycle and position in the ring buffer (a byte index) at which new
samples are being stored.
</p>
Parameters:
<ul>
	<li>hdevice: Ignored but must be present, at this time.</li>
	<li>cycleNum: Address of a long long where the cycle number will be stored.</li>
	<li>pointer: Address of an integer where the index value will be stored.
	The value returned will be in the range 0 to (the size of the ring buffer)-1.</li>
</ul>
Returns:
<ul>
	<li>TRUE Success.</li>
	<li>FALSE Failure. Acquisition not running.</li>
</ul>

<p>
Together "cycleNum" and "pointer" can be used to determine
if data overrun has occurred in the ring buffer since the last call.  Data overrun
is when a complete cycle of the buffer has occurred since the last call. For example,
it would be overrun if:
<ul>
	<li>either (cycleNum > (lastCycleNum+1))</li>
	<li>or ((cycleNum == (lastCycleNum+1)) and (pointer >= lastPointer))</li>
</ul>
</p>
<p>
When the ring buffer is being filled from a socket rather than the Usb,
a single FALSE return indicates that a re-sync has occurred; two FALSE returns
in a row indicate that acquisition has stopped.</p>
<p>Note: When using sync'ed READ_POINTER calls, both "cycleNum" and "pointer" are input
and output parameters.
</p>
<a href="#toc">Contents</a>
<br>
<br>


<a name="setconnect"></a>
<h4>VOID SET_CONNECT_NODE_PORT(const char *node, const char *port)</h4>

<p>Set the node and port to connect to if running in client mode.</p>
Parameters:
<ul>
	<li>node: The name or IP address of the "sample stream server".<br>
	The "sample stream server" is the system taking samples directly from
	the Usb.  Any name or address that works with "ping" should work.
	</li>
	<li>port: The port to connect to on the sample stream server.<br>
	</li>
</ul>
Returns:
<ul>
	<li>*Nothing*</li>
</ul>
<p>The connect node can be set also using parameter "connect_node"
in the "ringbuffer.ini" file.  The default is the loopback address,
"127.0.0.1".
</p>
<p>The connect port can be set also using parameter "connect_port"
in the "ringbuffer.ini" file.  The default is the "3113".
</p>
<p>
Setting the connect port to "0" disables any connection attempt.
</p>
<a href="#toc">Contents</a>
<br>
<br>

<a name="setlisten"></a>
<h4>VOID SET_LISTEN_PORT(const char *port)</h4>

<p>Set the port to listen to if running in sample server mode.</p>
Parameters:
<ul>
	<li>port: The port to listen to for a client connection request.<br>
	</li>
</ul>
Returns:
<ul>
	<li>*Nothing*</li>
</ul>
<p>The listen port can be set also using parameter "listen_port"
in the "ringbuffer.ini" file.  The default is the "3113".
</p>
<p>
Setting the listen port to "0" disables listening for client connection
attempts.
</p>
<a href="#toc">Contents</a>
<br>
<br>

<a name="setstridekb"></a>
<h4>VOID SET_STRIDE_KB(int kBytes)</h4>

<p>Set the STRIDE to be used.</p>
Parameters:
<ul>
	<li>kBytes: The approximate stride wanted, in kilobytes (k=1024).</li>
</ul>
Returns:
<ul>
	<li>*Nothing*</li>
</ul>
<p>STRIDE can be set also using parameters "stride_kb" or "stride_ms"
in the "ringbuffer.ini" file or by a call to SET_STRIDE_MS.
The default is 131072 bytes.
</p>
<a href="#toc">Contents</a>
<br>
<br>


<a name="setstridems"></a>
<h4>VOID SET_STRIDE_MS(int msec)</h4>

<p>Set the STRIDE to be used.</p>
Parameters:
<ul>
	<li>msec: The approximate stride wanted, in milliseconds.</li>
</ul>
Returns:
<ul>
	<li>*Nothing*</li>
</ul>
<p>STRIDE can be set also using parameters "stride_ms" or "stride_kb"
in the "ringbuffer.ini" file or by a call to SET_STRIDE_KB.
The default is 131072 bytes.
</p>
<a href="#toc">Contents</a>
<br>
<br>


<a name="setsync"></a>
<h4>VOID SET_SYNC(BOOL onOff)</h4>

<p>Set the SYNC value to be used.</p>
Parameters:
<ul>
	<li>onOff: TRUE or FALSE.</li>
</ul>
Returns:
<ul>
	<li>*Nothing*</li>
</ul>
<p>
When SYNC is TRUE, READ_POINTER and READ_POINTER_WITH_CYCLE expect position
values in the
parameters "cycleNum" and "pointer" when called and won't return until the
position changes; when SYNC is FALSE, these routines return immediately.
When the call doesn't return until there is a position
change, the caller doesn't loop burning up CPU time.</p>
SYNC can be set on/off also by using parameters "sync" or "nosync"
in the "ringbuffer.ini" file.
</p>
<a href="#toc">Contents</a>
<br>
<br>


<a name="settransfer"></a>
<h4>BOOL SET_TRANSFER_CHANNEL_REQUEST_RANGES(int numRanges, int *channelRanges)</h4>

<p>Set the channels to be transferred by socket from the Usb ring buffer.</p>
Parameters:
<ul>
	<li>numRanges: The number of channel ranges in the "channelRanges" array.
	The maximum number of ranges allowed is 16, which is 32 numbers.</li>
	<li>channelRanges: Pairs of channels numbers that represent channels to be transferred
	by socket from the Usb ring buffer.  Channel numbers count from 1.  Channel 1 (the
	sync channel) and channel 2 (the status channel) are always transferred and need not
	be requested.  Ranges must be specified in increasing numeric order.  </li>
</ul>
Returns:
<ul>
	<li>TRUE if successful.</li>
	<li>FALSE if not successful.</li>
</ul>
<p>
When the ring buffer is being filled from a socket, channels not transferred are
set to x'ffffff00'.
</p>
<a href="#toc">Contents</a>
<br>
<br>

<a name="usbwrite"></a>
<h4>BOOL USB_WRITE(HANDLE hdevice, PCHAR data)</h4>

<p>Write a 64 byte array to the BioSemi Usb Receiver.</p>
Parameters:
<ul>
	<li>hdevice: Ignored but must be present, at this time.</li>
	<li>data: A 64 byte array to be output to the BioSemi Usb Receiver.</li>
</ul>
Returns:
<ul>
	<li>TRUE if successful.</li>
	<li>FALSE if not successful.</li>
</ul>
<p>The byte array "data" is used to start and stop the flow of samples through the Usb
interface and to send trigger outputs:
<ul>
	<li>To start the flow send x'ff' in byte 0 followed by 63 bytes set to 0.</li>
	<li>To stop the flow send 64 bytes all set to 0.</li>
	<li>To send triggers during acquisition,
	<ul>
		<li>send x'ff' in byte 0</li>
		<li>8 trigger bits in byte 1</li>
		<li>7 trigger bits in byte 2</li>
		<li>followed by 61 bytes set to 0</li>
	</ul>
	<p>Sending triggers doesn't work if the program is running as a
	client, i.e. when its ring buffer is being filled from a Tcp
	socket.</p>
</ul>
</p>
<a href="#toc">Contents</a>

<a name="dleeprom"></a>
<h4>BOOL DOWNLOAD_FX2_EEPROM(void)</h4> 

<p>Download an FX2 EEPROM file using Usb.</p> 

Parameters:
<ul>
	<li>*None*</li>
</ul>
Returns:
<ul>
	<li>TRUE if successful.</li>
	<li>FALSE if not successful.</li>
</ul>

<p>The file to be downloaded must be called "USB2.iic".  It is expected
to exist in:
<ul>
<li>either the current directory</li>
<li>or:
<ul>
<li>on Windows: in "C:/BiosemiCAD/loopback/firmware/"</li>
<li>on Linux or OSX: in "/BiosemiCAD/loopback/firmware/"</li>
</ul>
</ul>
</p>
<a href="#toc">Contents</a>

<a name="dlfirmware"></a>
<h4>BOOL DOWNLOAD_FX2_IIC_FIRMWARE(void)</h4>

<p>Download an FX2 IIC Firmware file using Usb.</p> 

Parameters:
<ul>
	<li>*None*</li>
</ul>
Returns:
<ul>
	<li>TRUE if successful.</li>
	<li>FALSE if not successful.</li>
</ul>

<p>The file to be downloaded must be called "Vend_Ax.bix".  It is expected
to exist in:
<ul>
<li>either the current directory</li>
<li>or:
<ul>
<li>on Windows: in "C:/BiosemiCAD/loopback/Vend_ax/"</li>
<li>on Linux or OSX: in "/BiosemiCAD/loopback/Vend_ax/"</li>
</ul>
</ul>
</p>
<a href="#toc">Contents</a>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<h4>INT GET_REMOTE_ERRORCODE(void)</h4>
